#!/usr/bin/env python
from __future__ import absolute_import, division, print_function, unicode_literals
import os, sys
import subprocess
import tarfile
from optparse import OptionParser

LOCAL_DATA_PATH = os.environ.get('XDG_DATA_HOME')
if LOCAL_DATA_PATH is None:
    LOCAL_DATA_PATH = os.path.expanduser('~/.local/share')

DOTFILES_DATA = os.path.join(LOCAL_DATA_PATH, 'dotfiles')

NODE_VERSION_URL = 'https://semver.io/node/resolve/6'
_Failsafe_NODE_VERSION = '6.11.3'

node_packaging = [
    'bower',
    'npm-check-updates',
    'npm',
    'yarn',
    'local-npm',
]

yo_packages = [
    'generator-react-coffee-webpack',
    'generator-chrome-extension',
    'yo'
]

util_packages = [
    'http-server',
    'gitbook-cli',
    'js2coffee',
    'nesh',
    'underscore'
]

testing_packages = [
    'coffeelint',
    'mocha',
    'phantomjs-prebuilt',
]

dev_packages = [
    'electron',
    'gulp',
    # use new coffeescript 2.x
    'coffeescript',
    'grunt-cli',
    'webpack',
    'webpack-dev-middleware',
    # FIXME we are having problems with newer
    # dev servers.
    'webpack-dev-server@2.4.5'
]

misc_packages = [
    'cjsx-codemod',
    'madge',
    'knex'
]

GLOBAL_NODE_MODULES = node_packaging + yo_packages + util_packages
GLOBAL_NODE_MODULES += testing_packages + dev_packages + misc_packages

print(len(GLOBAL_NODE_MODULES), "GLOBAL_NODE_MODULES")


PYTHON_PACKAGES = [
    'virtualenvwrapper',
    'youtube-dl',
    'rarfile',
    'beautifulsoup4',
    'GitPython',
    'nodeenv',
    'cookiecutter',
    'PyGithub',
    'requests',
    'bpython',
    'ipython',
    'httpie',
]


def count_installed_pypkgs():
    cmd = ['pip', 'freeze']
    proc = subprocess.Popen(cmd, stdout=subprocess.PIPE)
    # FIXME
    proc.wait()
    count = 0
    for line in proc.stdout:
        count += 1
    return count

def install_pypkgs(plist=PYTHON_PACKAGES):
    for pkg in plist:
        cmd = ['pip', 'install', pkg]
        subprocess.check_call(cmd)

def install_nodeenv():
    import requests
    r = requests.get(NODE_VERSION_URL)
    if not r.ok:
        raise RuntimeError("Bad response")
    version = r.content
    print("Installing nodejs version", version)
    cmd = ['nodeenv', '-p', '-n', version]
    subprocess.check_call(cmd)

def update_npm():
    cmd = ['npm', 'up', '-g', 'npm']
    subprocess.check_call(cmd)

def install_node_globals(plist=GLOBAL_NODE_MODULES):
    cmd = ['npm', 'install', '-g'] + plist
    subprocess.check_call(cmd)

minishift_release_url = "https://github.com/minishift/minishift/releases/download/v%(version)s/minishift-%(version)s-linux-amd64.tgz"

def minishift_asset_prefix(version):
    return 'minishift-%s-linux-amd64.tgz' % version



def check_minishift(version='1.8.0'):
    from github import Github
    import requests
    g = Github()
    repo = g.get_user('minishift').get_repo('minishift')
    release = repo.get_release('v%s' % version)
    assets = release.raw_data['assets']
    tarball = None
    cksum = None
    prefix = minishift_asset_prefix(version)
    for asset in assets:
        if asset['name'].startswith(prefix):
            if asset['name'] == prefix:
                tarball = asset
            elif asset['name'] == '%s.sha256' % prefix:
                cksum = asset
    if tarball is None or cksum is None:
        raise RuntimeError("oops")
    print(tarball)
    tfilename = os.path.join(DOTFILES_DATA, tarball['name'])
    if not os.path.isfile(tfilename):
        print("Downloading", tarball['browser_download_url'])
        tres = requests.get(tarball['browser_download_url'])
        if not tres.ok:
            raise RuntimeError("bad response")
        with file(tfilename, 'w') as outfile:
            outfile.write(tres.content)
    tfile = tarfile.open(tfilename)
    fn = [f for f in tfile.getnames() if f.endswith('/minishift')][0]
    
    with tarfile.open(tfilename) as tfile:
        fn = [f for f in tfile.getnames() if f.endswith('/minishift')][0]
        print(fn)
        extracted = tfile.extractfile(fn)
        binfile = '/usr/local/bin/minishift'
        with file(binfile, 'w') as outfile:
            outfile.write(extracted.read())
    


# docker-machine-kvm
# https://docs.openshift.org/latest/minishift/getting-started/setting-up-driver-plugin.html
# sudo curl -L https://github.com/dhiltgen/docker-machine-kvm/releases/download/v0.7.0/docker-machine-driver-kvm -o /usr/local/bin/docker-machine-driver-kvm
# sudo chmod +x /usr/local/bin/docker-machine-driver-kvm


            
if __name__ == '__main__':
    vpath = os.environ.get('VIRTUAL_ENV')
    if vpath is None:
        print("we must be in a virtualenv named main")
        sys.exit(1)
    venv = os.path.basename(vpath)
    if venv != 'main':
        print("we must be in a virtualenv named main")
        sys.exit(1)
    if not os.path.isdir(DOTFILES_DATA):
        print("Creating", DOTFILES_DATA)
        os.makedirs(DOTFILES_DATA)
    if len(PYTHON_PACKAGES) > count_installed_pypkgs():
        print("Installing python packages...")
        install_pypkgs()
        
    npm_installed = False
    try:
        subprocess.check_call(['npm', '--version'])
        npm_installed = True
    except subprocess.CalledProcessError:
        pass
    except OSError as e:
        print(e)
        if e.errno != os.errno.ENOENT:
            raise e
    if not npm_installed:
        install_nodeenv()
        update_npm()
    modpath = os.path.join(vpath, 'lib', 'node_modules')
    global_modules = os.listdir(modpath)
    if len(global_modules) != len(GLOBAL_NODE_MODULES):
        print("INSTALLING GLOBAL NODE MODULES")
        install_node_globals()
    print("DOTFILES_DATA", DOTFILES_DATA)
    check_minishift()
    
